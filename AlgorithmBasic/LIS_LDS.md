# 최장 증가, 감소 부분 수열 (LIS, LDS)

- 어떤 임의의 수열이 주어질 때, 이 수열에서 몇 개의 수들을 제거해서 부분수열을 만들 수 있다. 이때 만들어진 부분수열 중 오름차순 또는 내림차순으로 정렬된 가장 긴 수열을 각각 최장 증가 부분 수열(LIS), 최장 감소 부분 수열(LDS)이라 한다.
- LIS, LDS 문제는 동적 계획법(Dynamic Programming)을 이용해서 풀 수 있다.
- LDS는 LIS를 구하는 과정에서 LIS의 길이를 구하는 것과 같으며 LDS는 LIS를 역으로 탐색하면 된다.

## 개념
- {1, 4, 3, 2, 1, 4, 3, 4, 5, 2}의 LIS를 구하는 과정을 살펴보자.
- 왼쪽에서 오른쪽으로 진행하는 오름차순의 경우 각 원소별 수열의 길이를 보면 다음과 같다.

```java
int[] arr = {1, 4, 3, 2, 1, 4, 3, 4, 5, 2};
int[] dp = new int[arr.length];
```
- dp[0] = {1}   // 길이: 1
- dp[1] = {1, 4}   // 길이: 2
- dp[2] = {1, 3}   // 길이: 2
- dp[3] = {1, 2}   // 길이: 2
- dp[4] = {1}   // 길이: 1
- dp[5] = {1, 4}   // 길이: 2
- dp[6] = {1, 3}   // 길이: 2
- dp[7] = {1, 3, 4}   // 길이: 3
- dp[8] = {1, 3, 4, 5}   // 길이: 4
- dp[9] = {1, 2}   // 길이: 2
- > dp[i]는 arr[i]를 마지막 원소로 가지는 LIS의 길이를 의미한다.
  
> LDS는 오른쪽에서 왼쪽으로 진행하면 된다.

- LIS와 LDS를 진행하면 결과는 아래와 같을 것이다.
```java
int[] lis = {1, 2, 2, 2, 1, 2, 2, 3, 4, 2};
int[] lds = {2, 4, 3, 2, 2, 1, 2, 2, 2, 1};
```

## 구현
```java

/**
 * LIS
 */

for (int i = 0; i < arr.length; i++) {
    dp[i] = 1;
    for (int j = 0; j < i; j++) {
        if (arr[j] < arr[i] && dp[i] < dp[j] + 1) {
            dp[i] = dp[j] + 1;
        }
    }
}

/**
 * LDS (LIS의 역방향)
 */
for (int i = arr.length -1; i >= 0; i--) {
    dp[i] = 1;
    
    for (int j = arr.length - 1; j > i; j--) {
        if (arr[j] < arr[i] && dp[i] < dp[j] + 1) {
            dp[i] = dp[j] + 1;
        }
    }
}
```
