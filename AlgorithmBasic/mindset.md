# 알고리즘 문제를 풀 때 기본적으로 가져야 할 생각

> 자료구조 및 알고리즘을 공부하면서 또는 알고리즘 문제를 풀면서 가장 기본적이면서 가장 중요하다고 생각하는 부분을 정리해봤습니다.

## 효율적으로 코딩 테스트 공부하는 방법
- 처음에는 주변에 잘하는 사람에게 물어보는 방식이 빠르게 실력이 늘 수 있습니다.
- 혼자 오래 고민하는 것은 힘만 빠지고 한계가 있을 것입니다. (혼자 고민하는 것은 최대 1 ~ 2시간까지만)
+ 혼자 오래 고민하는 것은 이미 실력이 어느 정도 쌓인 후에 하는 것이 좋을 것같습니다.

## 알고리즘 문제에 대한 마음가짐
- 효율성에서 fail되는 일은 없어야 합니다!
  - 입력에 대한 출력값이 제대로 나온다고 해도 시간 / 공간 복잡도에서 fail 나면 코딩 테스트에서는 틀린 거라고 생각해도 될 것입니다.
  - 로직은 어렵지않을 수 있지만 티어가 높은 문제들은 효율성을 따지기 때문에 어려운 것일 수 있습니다.

- 당연하지만, 문제의 조건에 부합하는 한 어떤 데이터든 들어올 수 있다고 생각해야 합니다.

## 코딩 테스트 기초
- 숏코딩이 반드시 좋은 것이 아닙니다.
  - 코드의 길이와 수행 시간은 비례하지 않습니다.

- 문제의 제한 조건에 부합하는 한 어떠한 테스트 케이스도 들어올 수 있습니다.
- 또한, 항상 최악의 케이스를 고려해야 합니다.

> 최악의 연산 횟수를 생각했을 때 시간 초과가 난다면 로직 생각 단계부터 틀렸다고 생각을 하고 다른 로직을 생각해야 합니다.

> CPU 연산 속도는 보통 1초에 1억 번 한다고 생각을 하면 될 것입니다.  
> 플랫폼에 따라 다를 수 있어 필자는 1초에 약 3천만 번을 고려합니다.

- 자바 코드에서 대략적으로 수행 속도 찍어보기
```java
public class Test {
  public static void main(String[] args) {
    long end = System.currentTimeMillis();

    /**
     * 로직
     */

    long end = System.currentTimeMillis();

    System.out.printf("%.4f\n", (end - start) / 1000.0);
  }
}
```

## 문제 푸는 순서!
- 코드를 작성하기 전에 시간 복잡도를 고려하고, 어느 정도 시간 복잡도 내에서 풀어야 할 지 미리 생각한다.
- 이 생각을 바탕으로 어떻게 구현할 수 있을 지 생각한다.
- 생각한 로직이 완성됐다면 구현을 시작한다.

> 미리 시간 복잡도를 생각하고 그 안에서 로직을 생각하는 것이 오히려 시간을 줄이는 방법이 될 것이다.  
> 이게 이번 글의 핵심입니다.

- 이를 테스트 해보기에 좋은 문제가 하나 있다.
> A 배열 = [5, 1, 10, 2, 4, 7] 이 있을 때, Query 배열 = [3, 4, 1, 15, 9, 11] 에 있는 각 숫자보다 작은 수가  
> A 배열에 몇 개 있는지 반환하는 프로그램을 작성하라.  
> 즉, 첫 번째 쿼리인 3 보다 작은 숫자는 A 배열에 [1, 2] 두 개 있기 때문에 첫 번째 쿼리에 대한 답은 2 이고,  
> 전체 쿼리에 대한 답은 [2, 2, 0, 6, 4, 6] 이 된다. A 배열과 Query 배열의 사이즈는 최대 100,000 이다.

<details>
<summary>핵심 보기</summary>
<div markdown="1">

- 각 Query 에 대해서 매번 A 배열 전체를 탐색하면 O(N^2) 이므로 100,000 * 100,000 라서 시간 초과가 발생한다.
- 이 문제를 시간 복잡도 O(N log N)으로 해결해야 한다.

</div>
</details>

<details>
<summary>정답 로직 보기</summary>
<div markdown="1">

- A 배열 = [5, 1, 10, 2, 4, 7]
- Query 배열 = [3, 4, 1, 15, 9, 11]

- A 배열을 정렬 = [1, 2, 4, 5, 7, 10]
- Query 배열을 쿼리 순서와 함께 정렬 = [ [1, 2] , [3, 0] , [4, 1] , [9, 4] , [11, 5] , [15, 3] ]
- Answer 배열 = [0, 0, 0, 0, 0, 0]

수도 코드
```java
int Aidx = 0

for -> Query q
    while (Aidx < A.length && q[0] > A[Aidx])
        idx += 1
    Answer[q[1]] = idx
```

</div>
</details>

> 문제를 풀기 전 시간 복잡도를 고려했는지 확인할 수 있는 문제였습니다.

다음 글은 자료구조를 사용할 때 기본 mindset을 다루려고 합니다.

## Wrap-up
> - 문제 풀이법을 고민할 때,
> - 시간 / 공간 복잡도를 고려한다.
> - 시간 / 메모리 초과는 정답으로 간주하지 않는다.

> - 내가 짠 로직의 시간 복잡도는 빅오 표기법으로 표현할 수 있어야 하며,
> - 공간 복잡도를 대략적으로 계산할 수 있어야 한다.

- 이번 글에서 가장 중요한 것은 `최악의 연산 횟수를 생각했을 때 시간 초과가 난다면 로직 생각 단계부터 틀렸다고 생각을 하고 다른 로직을 생각해야 한다` 입니다.
